// get document from frontend
// send document to HF Space directly (no more Flask)
// get back analyzed document

import AnalysisModel from "../models/analysis.model";
import { NextFunction, Response, Request } from "express";
import { ApiError } from "../utils/ApiError";
import { ApiResponse } from "../utils/ApiResponse";
import { User } from "../models/user.model";
import DocumentModel from "../models/document.model";
import axios from "axios";
import crypto from "crypto";
interface authRequest extends Request {
    user?: User
}

const analysis = async (req: authRequest, res: Response) => {
    try {
        const user = req.user;
        if (!user) {
            throw new ApiError(400, "No user present");
        }
        
        const documentId = req.params.documentId;
        if (!documentId) {
            throw new ApiError(400, "No document to analyze");
        }
        
        // Check for existing analysis
        const existingAnalysis = await AnalysisModel.findOne({
            documentId: documentId,
            userId: user._id
        });
        
        if (existingAnalysis) {
            res.status(200).json(new ApiResponse(201, existingAnalysis, "Analysis of document generated by existing"));
            return;
        }
        
        const retrievedDocument = await DocumentModel.findOne({ _id: documentId });
        if (!retrievedDocument) {
            throw new ApiError(404, "Document not found");
        }
        
        const documentUrl = retrievedDocument?.ClouinaryUrl;
        
        // Generate doc_id (same logic as Flask was using)
        const docId = require('crypto')
            .createHash('sha256')
            .update(`${documentId}_${user._id}_${Date.now()}`)
            .digest('hex')
            .substring(0, 16);
        
        console.log(`üîß Generated doc_id: ${docId} for document: ${documentId}`);
        
        // Call HF Space instead of Flask
        const hfSpaceUrl = `${process.env.HF_SPACE_URL}/analyze_document_url`;
        
        const response = await axios.post(hfSpaceUrl, {
            document_url: documentUrl,
            force_doc_id: docId // Send doc_id to HF Space
        }, {
            timeout: 600000,
            headers: {
                'Authorization': `Bearer ${process.env.HF_TOKEN}`,
                'Content-Type': 'application/json'
            }
        });
        
        const analysisData = response.data;
        const { 
            summary, 
            risky_terms, 
            key_clauses, 
            doc_id, 
            chat_ready, 
            vector_storage, 
            total_processing_time, 
            chunk_count,
            extracted_text_length,
            doc_id_source
        } = analysisData;
        
        if (!summary || !risky_terms || !key_clauses) {
            throw new ApiError(400, "Incomplete analysis received from HF Space");
        }
        
        // Verify doc_id alignment
        if (doc_id !== docId) {
            console.warn(`‚ö†Ô∏è Doc ID mismatch! Sent: ${docId}, Received: ${doc_id}`);
        }
        
        const newAnalysis = new AnalysisModel({
            userId: user._id,
            documentId,
            summary,
            risky_terms,
            key_clauses,
            flask_doc_id: doc_id, // Keep this field name for compatibility
            chat_ready: chat_ready || false,
            vector_storage_status: vector_storage === 'success' ? 'success' : 'failed',
            processing_time: total_processing_time,
            chunk_count: chunk_count || 0,
            // Add new fields for better tracking
            extracted_text_length: extracted_text_length || 0,
            doc_id_source: doc_id_source || 'nodejs_generated',
            analysis_source: 'hf_space'
        });
        
        const savedAnalysisResult = await newAnalysis.save();
        
        console.log(`‚úÖ Analysis completed for doc_id: ${doc_id}, ready for chat: ${chat_ready}`);
        
        res.status(200).json(new ApiResponse(201, savedAnalysisResult, "Analysis of document generated"));

    } catch (error: any) {
        console.error("Analysis error:", error);
        
        // Better error handling for different scenarios
        if (error.response?.status === 400) {
            res.status(400).json(new ApiError(400, error.response.data.detail || "Invalid request to analysis service"));
        } else if (error.response?.status === 500) {
            res.status(500).json(new ApiError(500, "Analysis service internal error"));
        } else if (error.code === 'ECONNABORTED') {
            res.status(408).json(new ApiError(408, "Analysis request timed out"));
        } else {
            res.status(500).json(new ApiError(500, "Error analyzing document"));
        }
    }
};

const getAnalysisById = async (req: authRequest, res: Response) => {
    try {
        const user = req.user;
        if (!user) {
            throw new ApiError(400, "No user present");
        }
        
        const document = req.params.documentId;
        const analyzedDocument = await AnalysisModel.findOne({
            userId: user._id,
            documentId: document
        });
        
        res.status(200).json(new ApiResponse(201, analyzedDocument, "Analysis of document retrieved"));
        
    } catch (error) {
        console.error("Get analysis error:", error);
        res.status(500).json(new ApiError(500, "Error getting document"));
    }
};

const chatWithDocumentStream = async (req: authRequest, res: Response) => {
    try {
        const user = req.user;
        if (!user) {
            throw new ApiError(400, "No user present");
        }

        const { documentId } = req.params;
        const { message } = req.body;

        if (!message?.trim()) {
            throw new ApiError(400, "Message is required");
        }

        const analysis = await AnalysisModel.findOne({
            userId: user._id,
            documentId: documentId
        });

        if (!analysis) {
            throw new ApiError(404, "Document analysis not found");
        }

        if (!analysis.chat_ready) {
            throw new ApiError(400, "Document is not ready for chat. Please wait for analysis to complete.");
        }

        const docId = analysis.flask_doc_id; // This contains our doc_id
        if (!docId) {
            throw new ApiError(400, "Document ID not found in analysis");
        }

        // Set up SSE headers
        res.writeHead(200, {
           'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        });

        res.write(`data: ${JSON.stringify({
            type: 'status',
            message: 'Processing your question...'
        })}\n\n`);

        try {
            // Call HF Space chat endpoint instead of Flask
            const chatResponse = await axios.post(`${process.env.HF_SPACE_URL}/chat`, {
                message: message,
                document_id: docId // Use the aligned doc_id
            }, {
                timeout: 60000,
                headers: {
                    'Authorization': `Bearer ${process.env.HF_TOKEN}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = chatResponse.data;

            if (!result.response) {
                res.write(`data: ${JSON.stringify({
                    type: 'error',
                    message: 'No response received from chat service'
                })}\n\n`);
                res.write(`data: ${JSON.stringify({ type: 'done' })}\n\n`);
                res.end();
                return;
            }

            // Stream the response word by word
            const words = result.response.split(' ');
            for (let i = 0; i < words.length; i++) {
                res.write(`data: ${JSON.stringify({
                    type: 'word',
                    word: words[i],
                    index: i
                })}\n\n`);
                
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // Send final complete response with metadata
            res.write(`data: ${JSON.stringify({
                type: 'complete',
                response: result.response,
                sources: result.sources || [],
                chunks_used: result.chunks_used || 0,
                document_id: result.document_id
            })}\n\n`);

        } catch (error: any) {
            console.error("Chat request error:", error);
            
            let errorMessage = "Error processing your question";
            if (error.response?.data?.error) {
                errorMessage = error.response.data.error;
            } else if (error.message) {
                errorMessage = error.message;
            }
            
            res.write(`data: ${JSON.stringify({
                type: 'error',
                message: errorMessage
            })}\n\n`);
        }

        res.write(`data: ${JSON.stringify({ type: 'done' })}\n\n`);
        res.end();

    } catch (error: any) {
        console.error("Streaming chat error:", error.message);
        if (!res.headersSent) {
            res.status(500).json(new ApiError(500, "Error in streaming chat"));
        }
    }
};
const guestAnalysis = async (req: Request, res: Response) => {
  try {
    const documentId = req.params.documentId;
    if (!documentId) {
      throw new ApiError(400, "No document to analyze");
    }

    const retrievedDocument = await DocumentModel.findOne({ _id: documentId });
    if (!retrievedDocument) {
      throw new ApiError(404, "Document not found");
    }

    const documentUrl = retrievedDocument?.ClouinaryUrl;

    const docId = crypto
      .createHash("sha256")
      .update(`${documentId}_${Date.now()}`)
      .digest("hex")
      .substring(0, 16);

    console.log(`‚öôÔ∏è Guest Analysis - Generated doc_id: ${docId}`);

    const hfSpaceUrl = `${process.env.HF_SPACE_URL}/analyze_document_url`;

    const response = await axios.post(
      hfSpaceUrl,
      {
        document_url: documentUrl,
        force_doc_id: docId,
      },
      {
        timeout: 600000,
        headers: {
          Authorization: `Bearer ${process.env.HF_TOKEN}`,
          "Content-Type": "application/json",
        },
      }
    );

    const analysisData = response.data;
    const {
      summary,
      risky_terms,
      key_clauses,
      doc_id,
      total_processing_time,
      chunk_count,
      extracted_text_length,
    } = analysisData;

    if (!summary || !risky_terms || !key_clauses) {
      throw new ApiError(400, "Incomplete analysis received from HF Space");
    }

    console.log(`‚úÖ Guest Analysis completed for doc_id: ${doc_id}`);

     res
      .status(200)
      .json(
        new ApiResponse(201, {
          summary,
          risky_terms,
          key_clauses,
          doc_id,
          total_processing_time,
          chunk_count,
          extracted_text_length,
        }, "Guest document analyzed successfully")
      );
  } catch (error: any) {
    console.error("Guest analysis error:", error);

    if (error.response?.status === 400) {
      res
        .status(400)
        .json(
          new ApiError(
            400,
            error.response.data.detail || "Invalid request to analysis service"
          )
        );
    } else if (error.response?.status === 500) {
      res.status(500).json(new ApiError(500, "Analysis service internal error"));
    } else if (error.code === "ECONNABORTED") {
      res
        .status(408)
        .json(new ApiError(408, "Analysis request timed out"));
    } else {
      res.status(500).json(new ApiError(500, "Error analyzing document"));
    }
  }
};

const analysisController = {
    analysis,
    getAnalysisById,
    chatWithDocumentStream,
    guestAnalysis
};

export default analysisController;
