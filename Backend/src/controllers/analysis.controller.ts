// get document from frontend
// send document to HF Space directly (no more Flask)
// get back analyzed document

import AnalysisModel from "../models/analysis.model";
import { NextFunction, Response, Request } from "express";
import { ApiError } from "../utils/ApiError";
import { ApiResponse } from "../utils/ApiResponse";
import { User } from "../models/user.model";
import DocumentModel from "../models/document.model";
import axios from "axios";

interface authRequest extends Request {
    user?: User
}

const analysis = async (req: authRequest, res: Response) => {
    try {
        const user = req.user;
        if (!user) {
            throw new ApiError(400, "No user present");
        }
        
        const documentId = req.params.documentId;
        if (!documentId) {
            throw new ApiError(400, "No document to analyze");
        }
        
        // Check for existing analysis
        const existingAnalysis = await AnalysisModel.findOne({
            documentId: documentId,
            userId: user._id
        });
        
        if (existingAnalysis) {
            res.status(200).json(new ApiResponse(201, existingAnalysis, "Analysis of document generated by existing"));
            return;
        }
        
        const retrievedDocument = await DocumentModel.findOne({ _id: documentId });
        if (!retrievedDocument) {
            throw new ApiError(404, "Document not found");
        }
        
        const documentUrl = retrievedDocument?.ClouinaryUrl;
        
        // Generate doc_id (same logic as Flask was using)
        const docId = require('crypto')
            .createHash('sha256')
            .update(`${documentId}_${user._id}_${Date.now()}`)
            .digest('hex')
            .substring(0, 16);
        
        console.log(`🔧 Generated doc_id: ${docId} for document: ${documentId}`);
        
        // Call HF Space instead of Flask
        const hfSpaceUrl = `${process.env.HF_SPACE_URL}/analyze_document_url`;
        
        const response = await axios.post(hfSpaceUrl, {
            document_url: documentUrl,
            force_doc_id: docId // Send doc_id to HF Space
        }, {
            timeout: 600000,
            headers: {
                'Authorization': `Bearer ${process.env.HF_TOKEN}`,
                'Content-Type': 'application/json'
            }
        });
        
        const analysisData = response.data;
        const { 
            summary, 
            risky_terms, 
            key_clauses, 
            doc_id, 
            chat_ready, 
            vector_storage, 
            total_processing_time, 
            chunk_count,
            extracted_text_length,
            doc_id_source
        } = analysisData;
        
        if (!summary || !risky_terms || !key_clauses) {
            throw new ApiError(400, "Incomplete analysis received from HF Space");
        }
        
        // Verify doc_id alignment
        if (doc_id !== docId) {
            console.warn(`⚠️ Doc ID mismatch! Sent: ${docId}, Received: ${doc_id}`);
        }
        
        const newAnalysis = new AnalysisModel({
            userId: user._id,
            documentId,
            summary,
            risky_terms,
            key_clauses,
            flask_doc_id: doc_id, // Keep this field name for compatibility
            chat_ready: chat_ready || false,
            vector_storage_status: vector_storage === 'success' ? 'success' : 'failed',
            processing_time: total_processing_time,
            chunk_count: chunk_count || 0,
            // Add new fields for better tracking
            extracted_text_length: extracted_text_length || 0,
            doc_id_source: doc_id_source || 'nodejs_generated',
            analysis_source: 'hf_space'
        });
        
        const savedAnalysisResult = await newAnalysis.save();
        
        console.log(`✅ Analysis completed for doc_id: ${doc_id}, ready for chat: ${chat_ready}`);
        
        res.status(200).json(new ApiResponse(201, savedAnalysisResult, "Analysis of document generated"));

    } catch (error: any) {
        console.error("Analysis error:", error);
        
        // Better error handling for different scenarios
        if (error.response?.status === 400) {
            res.status(400).json(new ApiError(400, error.response.data.detail || "Invalid request to analysis service"));
        } else if (error.response?.status === 500) {
            res.status(500).json(new ApiError(500, "Analysis service internal error"));
        } else if (error.code === 'ECONNABORTED') {
            res.status(408).json(new ApiError(408, "Analysis request timed out"));
        } else {
            res.status(500).json(new ApiError(500, "Error analyzing document"));
        }
    }
};

const getAnalysisById = async (req: authRequest, res: Response) => {
    try {
        const user = req.user;
        if (!user) {
            throw new ApiError(400, "No user present");
        }
        
        const document = req.params.documentId;
        const analyzedDocument = await AnalysisModel.findOne({
            userId: user._id,
            documentId: document
        });
        
        res.status(200).json(new ApiResponse(201, analyzedDocument, "Analysis of document retrieved"));
        
    } catch (error) {
        console.error("Get analysis error:", error);
        res.status(500).json(new ApiError(500, "Error getting document"));
    }
};

const chatWithDocumentStream = async (req: authRequest, res: Response) => {
    try {
        const user = req.user;
        if (!user) {
            throw new ApiError(400, "No user present");
        }

        const { documentId } = req.params;
        const { message } = req.body;

        if (!message?.trim()) {
            throw new ApiError(400, "Message is required");
        }

        const analysis = await AnalysisModel.findOne({
            userId: user._id,
            documentId: documentId
        });

        if (!analysis) {
            throw new ApiError(404, "Document analysis not found");
        }

        if (!analysis.chat_ready) {
            throw new ApiError(400, "Document is not ready for chat. Please wait for analysis to complete.");
        }

        const docId = analysis.flask_doc_id; // This contains our doc_id
        if (!docId) {
            throw new ApiError(400, "Document ID not found in analysis");
        }

        // Set up SSE headers
        res.writeHead(200, {
           'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        });

        res.write(`data: ${JSON.stringify({
            type: 'status',
            message: 'Processing your question...'
        })}\n\n`);

        try {
            // Call HF Space chat endpoint instead of Flask
            const chatResponse = await axios.post(`${process.env.HF_SPACE_URL}/chat`, {
                message: message,
                document_id: docId // Use the aligned doc_id
            }, {
                timeout: 60000,
                headers: {
                    'Authorization': `Bearer ${process.env.HF_TOKEN}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = chatResponse.data;

            if (!result.response) {
                res.write(`data: ${JSON.stringify({
                    type: 'error',
                    message: 'No response received from chat service'
                })}\n\n`);
                res.write(`data: ${JSON.stringify({ type: 'done' })}\n\n`);
                res.end();
                return;
            }

            // Stream the response word by word
            const words = result.response.split(' ');
            for (let i = 0; i < words.length; i++) {
                res.write(`data: ${JSON.stringify({
                    type: 'word',
                    word: words[i],
                    index: i
                })}\n\n`);
                
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // Send final complete response with metadata
            res.write(`data: ${JSON.stringify({
                type: 'complete',
                response: result.response,
                sources: result.sources || [],
                chunks_used: result.chunks_used || 0,
                document_id: result.document_id
            })}\n\n`);

        } catch (error: any) {
            console.error("Chat request error:", error);
            
            let errorMessage = "Error processing your question";
            if (error.response?.data?.error) {
                errorMessage = error.response.data.error;
            } else if (error.message) {
                errorMessage = error.message;
            }
            
            res.write(`data: ${JSON.stringify({
                type: 'error',
                message: errorMessage
            })}\n\n`);
        }

        res.write(`data: ${JSON.stringify({ type: 'done' })}\n\n`);
        res.end();

    } catch (error: any) {
        console.error("Streaming chat error:", error.message);
        if (!res.headersSent) {
            res.status(500).json(new ApiError(500, "Error in streaming chat"));
        }
    }
};

const analysisController = {
    analysis,
    getAnalysisById,
    chatWithDocumentStream
};

export default analysisController;
